#include <fstream>
#include <iostream>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <memory>
#include <array>
#include <inttypes.h>
#include <experimental/string_view>

#include "BitWriter.hpp"
#include "BitReader.hpp"

template<typename T = void>
class BinaryHuffmanTree{

    template<typename T3> struct _Leave;
    template<typename T2>
    struct _Node{
        _Node(const T2& data, float probability):data(std::make_pair(data, probability)){}
        std::pair<T2, float> data;

        std::unique_ptr<_Node<T2>> leftNode;
        std::unique_ptr<_Node<T2>> rightNode;
        const _Node<T2>* parentNode = nullptr;

        void generateCodings(){
            bool isLeave = true;
            if (this->leftNode){
                isLeave = false;
                this->leftNode->generateCodings();
            }
            if (this->rightNode){
                isLeave = false;
                this->rightNode->generateCodings();
            }

            if (isLeave){
                _Leave<T2>* THIS = static_cast<_Leave<T2>*>(this);
                std::vector<bool>& coding = THIS->m_Coding;
                for (const _Node<T2>* currentPtr = this->parentNode, *previousePtr = this;
                     currentPtr != nullptr;
                     currentPtr  = currentPtr->parentNode)
                {
                    // 1 coding left, 0 right
                    if (currentPtr->leftNode.get() == previousePtr)
                        coding.push_back(1);
                    else
                        coding.push_back(0);

                    previousePtr = currentPtr;
                }
                // vector is generated by bottom up approach -> inverse its order for top down
                std::reverse(std::begin(coding), std::end(coding));
            }
        }
        friend std::ostream& operator<<(std::ostream& os, const _Node<T2>& node){
            bool isLeave = true;
            if (node.leftNode){
                isLeave = false;
                os << *node.leftNode;
            }
            if (node.rightNode){
                isLeave = false;
                os << *node.rightNode;
            }

            if (isLeave){
                const std::vector<bool>& coding = static_cast<const _Leave<T2>&>(node).m_Coding;
                os << node.data.first << ": ";
                for (const auto& e : coding)
                    os << (int)e;

                os << "\r\t\t probabillity: " << std::fixed << std::setprecision(6) << node.data.second << std::endl;
            }
        }
    };
    template<typename T3> struct _Leave : public _Node<T3>{
        _Leave(const T3& data, float probability) : _Node<T3>(data, probability){}
        const _Leave<T3>* nextLeave = nullptr;
        std::vector<bool> m_Coding;
    };

public:
    typedef T value_type;

    template<typename _Container>
    static BinaryHuffmanTree<typename _Container::value_type> generateHuffmanTree(const _Container& containerType){
        // generate histogram
        typedef typename _Container::value_type VTYPE;
        typedef typename BinaryHuffmanTree<VTYPE>:: template _Node <VTYPE> NODE;
        typedef typename BinaryHuffmanTree<VTYPE>:: template _Leave<VTYPE> LEAVE;
        std::vector<std::unique_ptr<NODE>> elementCounter;

        // optional
        float numElements = 0;
        for (auto& e : containerType){
            bool elementFound = false;
            for (auto& iter : elementCounter){
                if (iter->data.first == e){
                    elementFound = true;
                    ++iter->data.second;
                    break;
                }
            }
            if (!elementFound){
                elementCounter.reserve(1);
                elementCounter.push_back(std::make_unique<LEAVE>(LEAVE(e, 1.f)));
            }
            ++numElements;
        }
        elementCounter.shrink_to_fit();
        for (auto& e : elementCounter)
            e->data.second /= numElements;

        // sort elements
        std::sort(std::begin(elementCounter), std::end(elementCounter), [](const auto& element1, const auto& element2) -> bool{
            if (element1->data.second < element2->data.second)
                return true;
            return false;
        });

        // create "leave" iterator
        LEAVE* leaveRoot = nullptr;
        for (auto iter = elementCounter.begin(); iter != elementCounter.end(); ++iter){
            LEAVE* current = static_cast<LEAVE*>(iter->get());
            current->nextLeave = leaveRoot;
            leaveRoot = current;
        }

        // create huffman tree
        for (std::size_t i = 0; i < elementCounter.size() - 1; ++i){
            // pick first 2 elements and stick them together
            // and stick them into the second element -> last element will be the tree's root
            std::unique_ptr<NODE>& ptr1 = elementCounter[i];
            std::unique_ptr<NODE>& ptr2 = elementCounter[i + 1];

            // create combined element
            std::unique_ptr<NODE> ptr = std::make_unique<NODE>(ptr1->data.first, ptr1->data.second + ptr2->data.second);
            ptr-> leftNode = std::move(ptr1);
            ptr->rightNode = std::move(ptr2);

            // write combined elemnt in right element
            ptr2 = std::move(ptr);
            ptr2->leftNode ->parentNode = ptr2.get();
            ptr2->rightNode->parentNode = ptr2.get();

            // sort elements again
            // using the "insertion sort" appraoch
            for(int iter = i + 1; iter < elementCounter.size() - 1; ++iter){
                auto& e1 = elementCounter[iter];
                auto& e2 = elementCounter[iter + 1];

                if (e1->data.second > e2->data.second)
                    std::swap(e1, e2);
                else
                    break;
            }
        }
        // generate codings
        elementCounter[elementCounter.size() - 1]->generateCodings();

        // last element contains all information on the tree and is its head element
        return {std::move(elementCounter[elementCounter.size() - 1]), leaveRoot};
    }

    template<typename _StringType>
    static BinaryHuffmanTree<T> getHuffmanTreeFromHeader(const _StringType& file){
        std::fstream inputFile(file, std::fstream::in);
        if (!inputFile)
            throw "Error: Header not Found exception";

        // FORMAT:
        // <number of symbols>, <sizeof(T)>, <count of bits for this symbol>, <symbol>, <coding>, <count of bits for this symbol>......
        //
        // EXAMPLE:
        //  Parameter T = char,  "|" will indicate 1 byte of data
        //
        // 0|0|0|2  |1      |24|'a'|'\63'   |32|'b'|'0'|'\64'
        //
        // 32 bit   8 bit   24 bit          32 bit
        //

        // get symbol count
        BitReader<> reader(inputFile);
        int32_t symbolCount;
        {
            char* tmp = reinterpret_cast<char*>(&symbolCount);
            for (int i = 0; i < 4; ++i)
                tmp[i] = reader.readByte();
        }

        char type = reader.readByte();
        if (type != sizeof(T))
            throw "Error, Types don't match";

        std::unique_ptr<_Node<T>> head = std::make_unique<_Node<T>>(_Node<T>(0, 0.f));;
        _Leave<T>* oldLeave = nullptr;

        for (int32_t i = 0; i < symbolCount && reader.good(); ++i) {
            // bit count to next symbol
            char codingSize = reader.readByte() - (1 + type) * 8; // probably better to encode coding size only

            // get symbol itself
            T symbol;
            {
                std::vector<char> tmp = reader.readBytes(type);
                symbol = reinterpret_cast<const T*>(tmp.data())[0];
            }

            // create leave
            std::vector<bool> coding = reader.readBits(codingSize);
            if (!coding.size())
                throw "Couldn't read coding for symbol: " + std::to_string(symbol);

            // probability hasn't been calculated -> default probability 0.f
            std::unique_ptr<_Leave<T>> currentLeave = std::make_unique<_Leave<T>>(_Leave<T>(symbol, 0.f));

            currentLeave->nextLeave = oldLeave;
            oldLeave = currentLeave.get();

            // start building tree
            std::unique_ptr<_Node<T>>* treePtr = &head;
            for (int i = 0; i < coding.size() - 1; ++i){
                bool left = coding[i];
                if (left){
                    if ((*treePtr)->leftNode == nullptr)
                        (*treePtr)->leftNode = std::make_unique<_Node<T>>(_Node<T>(0, 0.f)); // create dummy node

                    treePtr = &(*treePtr)->leftNode;
                }
                else{
                    if ((*treePtr)->rightNode == nullptr)
                        (*treePtr)->rightNode = std::make_unique<_Node<T>>(_Node<T>(0, 0.f)); // create dummy node

                    treePtr = &(*treePtr)->rightNode;
                }
            }

            // save coded leave
            if ((bool)coding[coding.size() - 1]){
                // left
                if ((*treePtr)->leftNode)
                    throw "Leave already exists";

                currentLeave->m_Coding = std::move(coding);
                (*treePtr)->leftNode = std::move(currentLeave);
            }
            else{
                if ((*treePtr)->rightNode)
                    throw "Leave already exists";

                currentLeave->m_Coding = std::move(coding);
                (*treePtr)->rightNode = std::move(currentLeave);
            }
        }
        return { std::move(head), oldLeave };
    }

    BinaryHuffmanTree<T>& operator=(const BinaryHuffmanTree<T>&    ) = delete;
    BinaryHuffmanTree<T>& operator=(      BinaryHuffmanTree<T>&& bt){
        this->m_Root = std::move(bt.m_Root);
        this->m_FirstLeave = std::move(bt.m_FirstLeave);
        return *this;
    }

    BinaryHuffmanTree(const BinaryHuffmanTree&) = delete;
    BinaryHuffmanTree(BinaryHuffmanTree&& bt) : m_Root(std::move(bt.m_Root)){}

    friend std::ostream& operator<< (std::ostream& os, BinaryHuffmanTree<T>& bt){
        const _Node<T>* ptr = bt.m_Root.get();
        os << *ptr;
        return os;
    }

    template<typename _ContainerType, typename _StringType>
    void parseCode(const _StringType filename, _ContainerType& container){
        std::fstream input(filename, std::fstream::in);
        if (!input)
            throw "Error, file can't be opened for reading";

        float bitCount = 0.f;
        float characterCount = 0.f;

        BitReader<> reader(input);
        while(reader.good()){
            std::unique_ptr<_Node<T>>* iter = &this->m_Root;

            // find symbol
            while((*iter)->leftNode || (*iter)->rightNode){
                bool left = reader.readBit();
                ++bitCount;

                if (left)
                    iter = &(*iter)->leftNode;
                else
                    iter = &(*iter)->rightNode;
            }
            container.push_back((*iter)->data.first);
            ++characterCount;
        }
        std::cout << "\nBit count: " << (int)bitCount << std::endl
                  << "Symbol count: " << (int)characterCount << std::endl
                  << "Average symbol length: " << bitCount / characterCount << std::endl << std::endl;
    }

    void writeHeaderToFile(std::experimental::string_view fileName){
        std::fstream output(std::string(fileName), std::fstream::out);
        if (!output)
            throw "Error, file can't be opened for writing";

        // write header
        // count leaves
        std::int32_t leaveCount = 0;
        for (const _Leave<T>* ptr = this->m_FirstLeave; ptr; ptr = ptr->nextLeave)
            ++leaveCount;

        // FORMAT:
        // <number of symbols>, <sizeof(T)>, <count of bits for this symbol>, <symbol>, <coding>, <count of bits for this symbol>......
        //
        // EXAMPLE:
        //  Parameter T = char,  "|" will indicate 1 byte of data
        //
        // 0|0|0|2  |1      |24|'a'|'\63'   |32|'b'|'0'|'\64'
        //
        // 32 bit   8 bit   24 bit          32 bit
        //
        BitWriter<> writer(output);

        char* values = reinterpret_cast<char*>(&leaveCount);
        writer.addByte(values[0]);
        writer.addByte(values[1]);
        writer.addByte(values[2]);
        writer.addByte(values[3]);
        writer.addByte((char)sizeof(T));

        for (const _Leave<T>* ptr = this->m_FirstLeave; ptr; ptr = ptr->nextLeave){
            writer.addByte(8 * (1 + /*count itself*/ + (char)sizeof(T)) + (char)ptr->m_Coding.size());
            const char* tmpPtr = reinterpret_cast<const char*>(&ptr->data.first);
            for (int i = 0; i < sizeof(T); ++i)
                writer.addByte(tmpPtr[i]);

            writer.addBits(ptr->m_Coding);
        }
        writer.flush();
    }

    template<typename _StringType1, typename _StringType2>
    void saveCodeString(const _StringType1& filename, const _StringType2& str){
        std::fstream output(filename, std::fstream::out);
        if (!output)
            throw "Error, file can't be opened for writing";

        BitWriter<> writer(output);
        constexpr int SIZE = sizeof(T) == 1 ? 256 : 1;

        if (SIZE > 1){
            // generate coding table
            std::array<const _Leave<T>*, SIZE> table;
            for (auto& e :table)
                e = nullptr;

            for (const _Leave<T>* iter = this->m_FirstLeave; iter; iter = iter->nextLeave)
                table[iter->data.first] = iter;

            // write symbols
            for (const auto& e : str){
                if (!table[e])
                    throw "Error, symbol not found in huffmantree";

                writer.addBits(table[e]->m_Coding);
            }
        }
        else{
            for (const auto& e : str){
                // search coding
                const _Leave<T>* iter = this->m_FirstLeave;
                for (; iter; iter = iter->nextLeave){
                    if (iter->data.first == e)
                        break;
                }
                if (!iter)
                    throw "Error, symbol not found in huffmantree";

                writer.addBits(iter->m_Coding);
            }
        }
        writer.flush();
    }

    float calculateEntropie(){
        float toReturn = 0.f;
        for (const _Leave<T>* ptr = this->m_FirstLeave; ptr; ptr = ptr->nextLeave)
            //toReturn += - ptr->data.second * ptr->m_Coding.size(); <= wrong
            toReturn += -1.f * std::log2(ptr->data.second) * ptr->data.second;

        return toReturn;
    }

    void printLeaves(){
        for (const _Leave<T>* iter = this->m_FirstLeave; iter != nullptr; iter = iter->nextLeave)
            std::cout << *iter;
    }

protected:
    template<typename _TYPE> friend class BinaryHuffmanTree;

    const _Leave<T>* m_FirstLeave;
    std::unique_ptr<_Node<T> > m_Root = nullptr;
    BinaryHuffmanTree() = default;
    BinaryHuffmanTree(std::unique_ptr<_Node<T> >&& root, const _Leave<T>* leaveIter = nullptr)
        : m_Root(std::move(root)), m_FirstLeave(leaveIter){}
};

